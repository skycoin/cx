%{
	package parsingcompletor
	import (
		"strconv"
		"github.com/skycoin/skycoin/src/cipher/encoder"
		"github.com/skycoin/cx/cx/ast"
		"github.com/skycoin/cx/cx/constants"
        "github.com/skycoin/cx/cx/types"
		"github.com/skycoin/cx/cxparser/actions"
	)

/*
This is a machine generated file
parsingcompletor.go is is generated by GOYACC from parsingcompletor.y

build-parser: ## Generate lexer and parser for CX grammar
  	./bin/goyacc -o cxparser/cxpartialparsing/cxpartialparsing.go cxparser/cxpartialparsing/cxpartialparsing.y
	./bin/goyacc -o cxparser/cxparsingcompletor/parsingcompletor.go cxparser/cxparsingcompletor/parsingcompletor.y

- parsingcompletor.go is output
- cxparser/cxparsingcompletor/parsingcompletor.y is input
*/
        
	// var actions.AST = MakeProgram(CALLSTACK_SIZE, STACK_SIZE, INIT_HEAP_SIZE)
	
	func Parse (lexer *Lexer) int {
		return yyParse(lexer)
	}
%}

%union{
	i int
	i8 int8
	i16 int16
	i32 int32
	i64 int64
	ui8 uint8
	ui16 uint16
	ui32 uint32
	ui64 uint64
	f32 float32
	f64 float64
	tok string
	bool bool
	string string
	stringA []string
	ints    []int

	line int
        lineStr string

	argument *ast.CXArgument
	arguments []*ast.CXArgument

	expression *ast.CXExpression
	expressions []ast.CXExpression

	SelectStatement actions.SelectStatement
	SelectStatements []actions.SelectStatement

	ReturnExpressions actions.ReturnExpressions

	arrayArguments [][]ast.CXExpression

    function *ast.CXFunction
    functionIndex ast.CXFunctionIndex
}

%token  <bool>          BOOLEAN_LITERAL
%token  <i8>            BYTE_LITERAL
%token  <i16>           SHORT_LITERAL
%token  <i32>           INT_LITERAL
%token  <i64>           LONG_LITERAL
%token  <ui8>           UNSIGNED_BYTE_LITERAL
%token  <ui16>          UNSIGNED_SHORT_LITERAL
%token  <ui32>          UNSIGNED_INT_LITERAL
%token  <ui64>          UNSIGNED_LONG_LITERAL
%token  <f32>           FLOAT_LITERAL
%token  <f64>           DOUBLE_LITERAL
%token  <tok>           FUNC OP LPAREN RPAREN LBRACE RBRACE LBRACK RBRACK IDENTIFIER
                        VAR COMMA PERIOD COMMENT STRING_LITERAL PACKAGE IF ELSE FOR TYPSTRUCT STRUCT
                        SEMICOLON NEWLINE
                        ASSIGN CASSIGN IMPORT RETURN GOTO GT_OP LT_OP GTEQ_OP LTEQ_OP EQUAL COLON NEW
                        EQUALWORD GTHANWORD LTHANWORD
                        GTHANEQ LTHANEQ UNEQUAL AND OR
                        ADD_OP SUB_OP MUL_OP DIV_OP MOD_OP REF_OP NEG_OP AFFVAR
                        PLUSPLUS MINUSMINUS REMAINDER LEFTSHIFT RIGHTSHIFT EXP
                        NOT
                        BITXOR_OP BITOR_OP BITCLEAR_OP
                        PLUSEQ MINUSEQ MULTEQ DIVEQ REMAINDEREQ EXPEQ
                        LEFTSHIFTEQ RIGHTSHIFTEQ BITANDEQ BITXOREQ BITOREQ

                        DEC_OP INC_OP PTR_OP LEFT_OP RIGHT_OP
                        GE_OP LE_OP EQ_OP NE_OP AND_OP OR_OP
                        ADD_ASSIGN AND_ASSIGN LEFT_ASSIGN MOD_ASSIGN
                        MUL_ASSIGN DIV_ASSIGN OR_ASSIGN RIGHT_ASSIGN
                        SUB_ASSIGN XOR_ASSIGN
                        BOOL F32 F64
                        I8 I16 I32 I64
                        STR
                        UI8 UI16 UI32 UI64
                        UNION ENUM CONST CASE DEFAULT SWITCH BREAK CONTINUE
                        TYPE
                        
                        /* Types */
                        BASICTYPE

                        /* Removers */
                        REM DEF EXPR FIELD CLAUSES OBJECT OBJECTS

                        /* Debugging */
                        DSTACK DPROGRAM DSTATE
                        /* Affordances */
                        AFF CAFF TAG INFER VALUE
                        /* Pointers */
                        ADDR

                        yyDefault

%type   <i32>           int_value

%type   <tok>           after_period
%type   <tok>           unary_operator
%type   <tok>           assignment_operator
%type   <i>             type_specifier
%type   <argument>      declaration_specifiers
%type   <argument>      declarator
%type   <argument>      direct_declarator
%type   <argument>      parameter_declaration
%type   <arguments>     parameter_type_list
%type   <arguments>     function_parameters
%type   <arguments>     parameter_list
%type   <arguments>     fields
%type   <arguments>     struct_fields
%type   <arguments>     id_list
%type   <arguments>     types_list

/* %type   <stringA>       package_identifier */
                                
%type   <expressions>   assignment_expression
%type   <expressions>   constant_expression
%type   <expressions>   conditional_expression
%type   <expressions>   logical_or_expression
%type   <expressions>   logical_and_expression
%type   <expressions>   exclusive_or_expression
%type   <expressions>   inclusive_or_expression
%type   <expressions>   and_expression
%type   <expressions>   relational_expression
%type   <expressions>   shift_expression
%type   <expressions>   additive_expression
%type   <expressions>   multiplicative_expression
%type   <expressions>   unary_expression
%type   <expressions>   argument_expression_list
%type   <expressions>   postfix_expression
%type   <expressions>   primary_expression

%type   <expressions>   struct_literal_expression
                        
%type   <expressions>   array_literal_expression_list
%type   <expressions>   array_literal_expression

%type   <expressions>   slice_literal_expression_list
%type   <expressions>   slice_literal_expression

%type	<ReturnExpressions>	return_expression

%type   <expressions>   selector //remove selectors

%type   <expressions>   struct_literal_fields
%type   <SelectStatement>   elseif
%type   <SelectStatements>   elseif_list

%type   <expressions>   declaration
//                      %type   <expressions>   init_declarator_list
//                      %type   <expressions>   init_declarator

%type   <expressions>   initializer

%type   <expressions>   expression
%type   <expressions>   block_item
%type   <expressions>   block_item_list
%type   <expressions>   compound_statement
%type   <expressions>   else_statement
%type   <expressions>   labeled_statement
%type   <expressions>   expression_statement
%type   <expressions>   selection_statement
%type   <expressions>   iteration_statement
%type   <expressions>   jump_statement
%type   <expressions>   statement

%type   <functionIndex>      function_header

%type   <string>        infer_action_arg
%type   <stringA>       infer_action, infer_actions
%type   <expressions>   infer_clauses

%type   <ints>          indexing_literal
%type   <ints>          indexing_slice_literal
                        
			// for struct literals
%right                   IDENTIFIER LBRACE
                        
/* %start                  translation_unit */
%%



translation_unit:
                external_declaration
        |       translation_unit external_declaration
        ;

external_declaration:
                package_declaration
        |       global_declaration
        |       function_declaration
        |       import_declaration
        |       struct_declaration

        |       debugging
        ;

debugging:      
                DPROGRAM
                {
			actions.AST.PrintProgram()
                }
        ;

//delete selector, but cannot because goyacc segfaults
selector:
                IMPORT STRING_LITERAL IDENTIFIER SEMICOLON
                {
                //
                }
                ;

global_declaration:
                VAR declarator declaration_specifiers SEMICOLON
                {
			actions.DeclareGlobalInPackage(actions.AST,nil,$2, $3, nil, false)
                }
        |       VAR declarator declaration_specifiers ASSIGN initializer SEMICOLON
                {
			actions.DeclareGlobalInPackage(actions.AST,nil,$2, $3, $5, true)
                }
                ;

struct_declaration:
                TYPE IDENTIFIER STRUCT struct_fields
                {
		        actions.DeclareStruct(actions.AST,$2, $4)
                }
                ;

struct_fields:
                LBRACE RBRACE SEMICOLON
                { $$ = nil }
        |       LBRACE fields RBRACE SEMICOLON
                { $$ = $2 }
        ;

fields:         parameter_declaration SEMICOLON
                {
			$$ = []*ast.CXArgument{$1}
                }
        |       fields parameter_declaration SEMICOLON
                {
			$$ = append($1, $2)
                }
        ;

package_declaration:
                PACKAGE IDENTIFIER SEMICOLON
                {
			actions.DeclarePackage(actions.AST,$2)
                }
                ;

import_declaration:
                IMPORT STRING_LITERAL SEMICOLON
                {
			// DeclareImport($2)
                }
        ;

function_header:
                FUNC IDENTIFIER
                {
			// yylval.line = 0
			$$ = actions.FunctionHeader(actions.AST,$2, nil, false)
                }
        |       FUNC LPAREN parameter_type_list RPAREN IDENTIFIER
                {
			$$ = actions.FunctionHeader(actions.AST,$5, $3, true)
                }
        ;

function_parameters:
                LPAREN RPAREN
                { $$ = nil }
        |       LPAREN parameter_type_list RPAREN
                { $$ = $2 }
                ;

function_declaration:
                function_header function_parameters compound_statement
                {
			actions.FunctionDeclaration(actions.AST,$1, $2, nil, $3)
                }
        |       function_header function_parameters function_parameters compound_statement
                {
			actions.FunctionDeclaration(actions.AST,$1, $2, $3, $4)
                }
        ;

parameter_type_list:
		parameter_list
                ;

parameter_list:
                parameter_declaration
                {
			$$ = []*ast.CXArgument{$1}
                }
	|       parameter_list COMMA parameter_declaration
                {
			$$ = append($1, $3)
                }
                ;

parameter_declaration:
                declarator declaration_specifiers
                {
			$2.Name = $1.Name
			$2.Package = $1.Package

			$$ = $2
                }
                ;

declarator:     direct_declarator
                ;

direct_declarator:
                IDENTIFIER
                {
			if pkg, err := actions.AST.GetCurrentPackage(); err == nil {
				arg := ast.MakeArgument("", actions.CurrentFile, actions.LineNo)
				arg.SetType(types.UNDEFINED)
				arg.Name = $1
				arg.Package = ast.CXPackageIndex(pkg.Index)
				$$ = arg
			} else {
				panic(err)
			}
                }
	|       LPAREN declarator RPAREN
                { $$ = $2 }
                ;

id_list:	IDENTIFIER
		{
			arg := actions.DeclarationSpecifiersStruct(actions.AST,$1, "", false, actions.CurrentFile, actions.LineNo)
			$$ = []*ast.CXArgument{arg}
		}
	|	type_specifier
		{
			arg := actions.DeclarationSpecifiersBasic(types.Code($1))
			$$ = []*ast.CXArgument{arg}
		}
	|	id_list COMMA IDENTIFIER
		{
			arg := actions.DeclarationSpecifiersStruct(actions.AST,$3, "", false, actions.CurrentFile, actions.LineNo)
			$$ = append($1, arg)
		}
	|	id_list COMMA type_specifier
		{
			arg := actions.DeclarationSpecifiersBasic(types.Code($3))
			$$ = append($1, arg)
		}
	;



types_list:

		LPAREN id_list RPAREN

		{

			$$ = $2

		}
	|	LPAREN RPAREN
		{
			$$ = nil
		}
	;

declaration_specifiers:
                FUNC types_list types_list
		{
			arg := ast.MakeArgument("", actions.CurrentFile, actions.LineNo).SetType(types.FUNC)
                       
			arg.Inputs =  actions.AST.AddPointerArgsToCXArgsArray($2)
			arg.Outputs =  actions.AST.AddPointerArgsToCXArgsArray($3)
			$$ = actions.DeclarationSpecifiers(arg, []types.Pointer{0}, constants.DECL_FUNC)
		}
        |       MUL_OP declaration_specifiers
                {
			$$ = actions.DeclarationSpecifiers($2, []types.Pointer{0}, constants.DECL_POINTER)
                }
        // |       LBRACK INT_LITERAL RBRACK declaration_specifiers
        //         {
	// 		$$ = actions.DeclarationSpecifiers($4, types.Cast_sint_to_sptr($2), constants.DECL_ARRAY)
        //         }
        |       LBRACK RBRACK declaration_specifiers
                {
			$$ = actions.DeclarationSpecifiers($3, []types.Pointer{0}, constants.DECL_SLICE)
                }
        |       type_specifier
                {
			$$ = actions.DeclarationSpecifiersBasic(types.Code($1))
                }
        |       IDENTIFIER
                {
			$$ = actions.DeclarationSpecifiersStruct(actions.AST,$1, "", false, actions.CurrentFile, actions.LineNo)
                }
        |       indexing_literal type_specifier
                {
			basic := actions.DeclarationSpecifiersBasic(types.Code($2))
			$$ = actions.DeclarationSpecifiers(basic, types.Cast_sint_to_sptr($1), constants.DECL_ARRAY)
                }
        |       indexing_literal IDENTIFIER
                {
			strct := actions.DeclarationSpecifiersStruct(actions.AST,$2, "", false, actions.CurrentFile, actions.LineNo)
			$$ = actions.DeclarationSpecifiers(strct, types.Cast_sint_to_sptr($1), constants.DECL_ARRAY)
                }
        |       IDENTIFIER PERIOD IDENTIFIER
                {
			$$ = actions.DeclarationSpecifiersStruct(actions.AST,$3, $1, true, actions.CurrentFile, actions.LineNo)
                }
	|       type_specifier PERIOD IDENTIFIER
                {
			$$ = actions.DeclarationSpecifiersStruct(actions.AST,$3, types.Code($1).Name(), true, actions.CurrentFile, actions.LineNo)
                }
        /* |       package_identifier */
        /*         { */
	/* 		$$ = actions.DeclarationSpecifiersStruct(actions.AST,$1[1], $1[0], true) */
        /*         } */
		/* type_specifier declaration_specifiers */
	/* |       type_specifier */
	/* |       type_qualifier declaration_specifiers */
	/* |       type_qualifier */
                ;

type_specifier:
                AFF
                { $$ = int(types.AFF) }
        |       BOOL
                { $$ = int(types.BOOL) }
        |       STR
                { $$ = int(types.STR) }
        |       F32
                { $$ = int(types.F32) }
        |       F64
                { $$ = int(types.F64) }
        |       I8
                { $$ = int(types.I8) }
        |       I16
                { $$ = int(types.I16) }
        |       I32
                { $$ = int(types.I32) }
        |       I64
                { $$ = int(types.I64) }
        |       UI8
                { $$ = int(types.UI8) }
        |       UI16
                { $$ = int(types.UI16) }
        |       UI32
                { $$ = int(types.UI32) }
        |       UI64
                { $$ = int(types.UI64) }
                ;


struct_literal_fields:
                // empty
                { $$ = nil }
        |       IDENTIFIER COLON constant_expression
                {
                        for i:=0;i<len($3);i++{
                                if $3[i].Type!=ast.CX_LINE{
                                        if $3[i].IsStructLiteral() {
                                                $$ = actions.StructLiteralAssignment(actions.AST,[]ast.CXExpression{actions.StructLiteralFields(actions.AST,$1)}, $3)
                                        } else {
                                                $$ = actions.Assignment(actions.AST,[]ast.CXExpression{actions.StructLiteralFields(actions.AST,$1)}, "=", $3)
                                        }
                                        break
                                }
                        }
                }
        |       struct_literal_fields COMMA IDENTIFIER COLON constant_expression
                {
                        for i:=0;i<len($5);i++{
                                if $5[i].Type!=ast.CX_LINE{
                                        if $5[i].IsStructLiteral() {
                                                $$ = append($1, actions.StructLiteralAssignment(actions.AST,[]ast.CXExpression{actions.StructLiteralFields(actions.AST,$3)}, $5)...)
                                        } else {
                                                $$ = append($1, actions.Assignment(actions.AST,[]ast.CXExpression{actions.StructLiteralFields(actions.AST,$3)}, "=", $5)...)
                                        }
                                        break
                                }
                        }
                }
                ;

array_literal_expression_list:
                assignment_expression
                {
			$1[len($1) - 1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
			$$ = $1
                }
	|       array_literal_expression_list COMMA assignment_expression
                {
			$3[len($3) - 1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
			$$ = append($1, $3...)
                }
                ;

indexing_literal:
		LBRACK INT_LITERAL RBRACK
		{
			$$ = []int{int($2)}
		}
        |       indexing_literal LBRACK INT_LITERAL RBRACK
		{
			$$ = append($1, int($3))
		}
		;

indexing_slice_literal:
		LBRACK RBRACK
		{
			$$ = []int{0}
		}
        |       indexing_slice_literal LBRACK RBRACK
		{
			$$ = append($1, 0)
		}
		;

// expressions
array_literal_expression:
                indexing_literal IDENTIFIER LBRACE array_literal_expression_list RBRACE
                {
			$$ = $4
                }
        |       indexing_literal IDENTIFIER LBRACE RBRACE
                {
			$$ = nil
                }
        |       indexing_literal type_specifier LBRACE array_literal_expression_list RBRACE
                {
			$$ = actions.ArrayLiteralExpression(actions.AST,types.Cast_sint_to_sptr($1), types.Code($2), $4)
                }
        |       indexing_literal type_specifier LBRACE RBRACE
                {
			$$ = nil
                }
                ;







slice_literal_expression_list:
                assignment_expression
                {
			$1[len($1) - 1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
			$$ = $1
                }
	|       slice_literal_expression_list COMMA assignment_expression
                {

			$3[len($3) - 1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
			$$ = append($1, $3...)
                }
                ;

slice_literal_expression:
                LBRACK RBRACK IDENTIFIER LBRACE slice_literal_expression_list RBRACE
                {
			$$ = $5
                }
        |       LBRACK RBRACK IDENTIFIER LBRACE RBRACE
                {
			$$ = nil
                }
        |       LBRACK RBRACK type_specifier LBRACE slice_literal_expression_list RBRACE
                {
			$$ = actions.SliceLiteralExpression(actions.AST,types.Code($3), $5)
                }
        |       LBRACK RBRACK type_specifier LBRACE RBRACE
                {
			$$ = nil
                }
        |       LBRACK RBRACK slice_literal_expression
                {
                        lastExpression, err := actions.AST.GetCXAtomicOpFromExpressions($3,len($3) - 1)
                        if err != nil {
                                panic(err)
                        }

			for _, expr := range $3 {
                                if expr.Type==ast.CX_LINE{
                                        continue
                                }
                                expression, err := actions.AST.GetCXAtomicOp(expr.Index)
                                if err != nil {
                                        panic(err)
                                }

                                expressionOutputTypeSig:=actions.AST.GetCXTypeSignatureFromArray(expression.GetOutputs(actions.AST)[0])
                                var expressionOutputArg *ast.CXArgument = &ast.CXArgument{}
			        if expressionOutputTypeSig.Type == ast.TYPE_CXARGUMENT_DEPRECATE {
				        expressionOutputArg = actions.AST.GetCXArgFromArray(ast.CXArgumentIndex(expressionOutputTypeSig.Meta))
			        } else {
				        continue
			        }

                                expressionOutput:= expressionOutputArg
                                lastExpressionInputTypeSig:=actions.AST.GetCXTypeSignatureFromArray(lastExpression.GetInputs(actions.AST)[0])
				if expressionOutput.Name == lastExpressionInputTypeSig.Name {
					expressionOutput.Lengths = append(expressionOutput.Lengths, 0)
					expressionOutput.DeclarationSpecifiers = append(expressionOutput.DeclarationSpecifiers, constants.DECL_SLICE)
                                }
			}
	
			$3[len($3)-1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
			$$ = $3
                }
                ;

infer_action_arg:
                IDENTIFIER
                {
			$$ = $1
                }
        |       int_value
                {
			$$ = strconv.Itoa(int($1))
                }
	|	type_specifier PERIOD IDENTIFIER
		{
			$$ = types.Code($1).Name() + "." + $3
		}
        ;

infer_action:
                IDENTIFIER LPAREN infer_action_arg COMMA IDENTIFIER RPAREN
		{
			res := append([]string{$3}, $5)
			res = append(res, $1)
			$$ = res
		}
	|	IDENTIFIER LPAREN infer_action_arg RPAREN
		{
			$$ = append([]string{$1}, $3)
		}
	|	IDENTIFIER LPAREN infer_action RPAREN
		{
			$$ = append($3, $1)
		}
	|	IDENTIFIER LPAREN infer_action COMMA infer_action RPAREN
		{
			res := append($3, $5...)
			$$ = append(res, $1)
		}
        ;

infer_actions:
                infer_action SEMICOLON
                {
			$$ = $1
                }
        |       infer_actions infer_action SEMICOLON
                {
			$1 = append($1, $2...)
			$$ = $1
                }
                ;
        ;

infer_clauses:
                {
			$$ = actions.SliceLiteralExpression(actions.AST,types.AFF, nil)
                }
        |       infer_actions
                {
			var exprs []ast.CXExpression
			for _, str := range $1 {
				expr := actions.WritePrimaryExprs(actions.AST,types.AFF, encoder.Serialize(str), false)
				expr[len(expr) - 1].ExpressionType = ast.CXEXPR_ARRAY_LITERAL
				exprs = append(exprs, expr...)
			}
			
			$$ = actions.SliceLiteralExpression(actions.AST,types.AFF, exprs)
                }
                ;


int_value:
            INT_LITERAL
            {
		    $$ = $1
            }
        |   SUB_OP INT_LITERAL
            {
		    $$ = -$2
            }

primary_expression:
                IDENTIFIER
                {
			$$ = actions.PrimaryIdentifier(actions.AST,$1)
                }
	|	FUNC LPAREN RPAREN
		{
			$$ = nil
		}
        |       INFER LBRACE infer_clauses RBRACE
                {
			$$ = $3
                }
        |       STRING_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.STR, types.Make_obj([]byte($1)), false)
                }
        |       BOOLEAN_LITERAL
                {
			exprs := actions.WritePrimaryExprs(actions.AST,types.BOOL, encoder.Serialize($1), false)
			$$ = exprs
                }
        |       BYTE_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.I8, encoder.Serialize($1), false)
                }
        |       SHORT_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.I16, encoder.Serialize($1), false)
                }
        |       INT_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.I32, encoder.Serialize($1), false)
                }
        |       LONG_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.I64, encoder.Serialize($1), false)
                }
        |       UNSIGNED_BYTE_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.UI8, encoder.Serialize($1), false)
                }
        |       UNSIGNED_SHORT_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.UI16, encoder.Serialize($1), false)
                }
        |       UNSIGNED_INT_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.UI32, encoder.Serialize($1), false)
                }
        |       UNSIGNED_LONG_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.UI64, encoder.Serialize($1), false)
                }
        |       FLOAT_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.F32, encoder.Serialize($1), false)
                }
        |       DOUBLE_LITERAL
                {
			$$ = actions.WritePrimaryExprs(actions.AST,types.F64, encoder.Serialize($1), false)
                }
        |       LPAREN expression RPAREN
                { $$ = $2 }
        |       array_literal_expression
                {
			$$ = $1
                }
        |       slice_literal_expression
                {
			$$ = $1
                }
                ;

after_period:   type_specifier
                {
			$$ = types.Code($1).Name()
                }
        |       IDENTIFIER
        ;

postfix_expression:
		primary_expression
	|       postfix_expression LBRACK expression RBRACK
                {
			$$ = actions.PostfixExpressionArray(actions.AST,$1, $3)
                }
        |       type_specifier PERIOD after_period
                {
			$$ = actions.PostfixExpressionNative(actions.AST,types.Code($1), $3)
                }
	|       postfix_expression LPAREN RPAREN
                {
			$$ = actions.PostfixExpressionEmptyFunCall(actions.AST,$1)
                }
	|       postfix_expression LPAREN argument_expression_list RPAREN
                {
			$$ = actions.PostfixExpressionFunCall(actions.AST,$1, $3)
                }
	|       postfix_expression INC_OP
                {
			$$ = actions.PostfixExpressionIncDec(actions.AST,$1, true)
                }
        |       postfix_expression DEC_OP
                {
			$$ = actions.PostfixExpressionIncDec(actions.AST,$1, false)
                }
        |       postfix_expression PERIOD IDENTIFIER
                {
			$$ = actions.PostfixExpressionField(actions.AST,$1, $3)
                }
                ;

argument_expression_list:
                assignment_expression
	|       argument_expression_list COMMA assignment_expression
                {
			$$ = append($1, $3...)
                }
                ;

unary_expression:
                postfix_expression
	|       INC_OP unary_expression
                {
			// TODO
			$$ = $2
                }
	|       DEC_OP unary_expression
                {
			// TODO
			$$ = $2
                }
	|       unary_operator unary_expression
                {
			$$ = actions.UnaryExpression(actions.AST,$1, $2)
                }
                ;

unary_operator:
                REF_OP
	|       MUL_OP
	|       ADD_OP
	|       SUB_OP
	|       NEG_OP
                ;

multiplicative_expression:
                unary_expression
        |       multiplicative_expression MUL_OP unary_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_MUL)
                }
        |       multiplicative_expression DIV_OP unary_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_DIV)
                }
        |       multiplicative_expression MOD_OP unary_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_MOD)
                }
                ;

additive_expression:
                multiplicative_expression
        |       additive_expression ADD_OP multiplicative_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_ADD)
                }
	|       additive_expression SUB_OP multiplicative_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_SUB)
                }
                ;

shift_expression:
                additive_expression
        |       shift_expression LEFT_OP additive_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITSHL)
                }
        |       shift_expression RIGHT_OP additive_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITSHR)
                }
        |       shift_expression BITCLEAR_OP additive_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITCLEAR)
                }
                ;

relational_expression:
                shift_expression
        |       relational_expression EQ_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_EQUAL)
                }
        |       relational_expression NE_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_UNEQUAL)
                }
        |       relational_expression LT_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_LT)
                }
        |       relational_expression GT_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_GT)
                }
        |       relational_expression LTEQ_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_LTEQ)
                }
        |       relational_expression GTEQ_OP shift_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_GTEQ)
                }
                ;

and_expression: relational_expression
        |       and_expression REF_OP relational_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITAND)
                }
                ;

exclusive_or_expression:
                and_expression
        |       exclusive_or_expression BITXOR_OP and_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITXOR)
                }
                ;

inclusive_or_expression:
                exclusive_or_expression
        |       inclusive_or_expression BITOR_OP exclusive_or_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BITOR)
                }
                ;

logical_and_expression:
                inclusive_or_expression
	|       logical_and_expression AND_OP inclusive_or_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BOOL_AND)
                }
                ;

logical_or_expression:
                logical_and_expression
	|       logical_or_expression OR_OP logical_and_expression
                {
			$$ = actions.OperatorExpression(actions.AST,$1, $3, constants.OP_BOOL_OR)
                }
                ;

conditional_expression:
                logical_or_expression
	|       logical_or_expression '?' expression COLON conditional_expression
                ;

struct_literal_expression:
		conditional_expression
	|       IDENTIFIER LBRACE struct_literal_fields RBRACE
                {
			$$ = actions.PrimaryStructLiteral(actions.AST,$1, $3)
                }
	|       unary_operator IDENTIFIER LBRACE struct_literal_fields RBRACE
                {
			$$ = actions.UnaryExpression(actions.AST,$1, actions.PrimaryStructLiteral(actions.AST,$2, $4))
                }
        |       postfix_expression PERIOD IDENTIFIER LBRACE struct_literal_fields RBRACE
                {
                        cxAtomicOp, err := actions.AST.GetCXAtomicOpFromExpressions($1,0)
                        if err != nil {
                                panic(err)
                        }
                        cxAtomicOpOutputTypeSig:=actions.AST.GetCXTypeSignatureFromArray(cxAtomicOp.GetOutputs(actions.AST)[0])
			$$ = actions.PrimaryStructLiteralExternal(actions.AST,cxAtomicOpOutputTypeSig.Name, $3, $5)
                }
                ;

assignment_expression:
                struct_literal_expression
	|       unary_expression assignment_operator assignment_expression
                {
                       
			if $3 == nil {
				$$ = nil
			}
			if $3 != nil {
                                for i:=0;i<len($3);i++{
                                        if $3[i].Type!=ast.CX_LINE{
                                                if $3[i].IsArrayLiteral() {
                                                        if $2 != "=" && $2 != ":=" {
                                                                panic("")
                                                        }
                                                        if $2 == ":=" {
                                                                for _, from := range $3 {
                                                                        if from.Type==ast.CX_LINE{
                                                                                continue
                                                                        }

                                                                        fromExpression,err := actions.AST.GetCXAtomicOp(from.Index)
                                                                        if err != nil {
                                                                                panic(err)
                                                                        }

                                                                        fromExpressionOutputTypeSig:=actions.AST.GetCXTypeSignatureFromArray(fromExpression.GetOutputs(actions.AST)[0])
                                                                        fromExpressionOutputIdx:= fromExpressionOutputTypeSig.Meta
                                                                        actions.AST.CXArgs[fromExpressionOutputIdx].PreviouslyDeclared = true
                                                                }
                                                        }
                                                        $$ = actions.ArrayLiteralAssignment(actions.AST,$1, $3)
                                                } else if $3[len($3) - 1].IsStructLiteral() {
                                                        if $2 != "=" && $2 != ":=" {
                                                                panic("")
                                                        }
                                                        if $2 == ":=" {
                                                                for _, from := range $3 {
                                                                        if from.Type==ast.CX_LINE{
                                                                                continue
                                                                        }

                                                                        fromExpression, err := actions.AST.GetCXAtomicOp(from.Index)
                                                                        if err != nil {
                                                                                panic(err)
                                                                        }

                                                                        fromExpressionOutputTypeSig:=actions.AST.GetCXTypeSignatureFromArray(fromExpression.GetOutputs(actions.AST)[0])
                                                                        fromExpressionOutputIdx:=fromExpressionOutputTypeSig.Meta
                                                                        actions.AST.CXArgs[fromExpressionOutputIdx].PreviouslyDeclared = true
                                                                }
                                                        }
                                                        $$ = actions.StructLiteralAssignment(actions.AST,$1, $3)
                                                } else {
                                                        $$ = actions.Assignment(actions.AST,$1, $2, $3)
                                                }

                                                break
                                        }
                                }
			}
                }
                ;

assignment_operator:
                ASSIGN
        |       CASSIGN
	|       MUL_ASSIGN
	|       DIV_ASSIGN
	|       MOD_ASSIGN
	|       ADD_ASSIGN
	|       SUB_ASSIGN
	|       LEFT_ASSIGN
	|       RIGHT_ASSIGN
	|       AND_ASSIGN
	|       XOR_ASSIGN
	|       OR_ASSIGN
                ;

expression:     assignment_expression
	|       expression COMMA assignment_expression
                {               
                        lastOfThirdAtomicOp, err := actions.AST.GetCXAtomicOpFromExpressions($3,len($3) - 1)
                        if err != nil {
                                panic(err)
                        }

                        lastOfFirstAtomicOp,err := actions.AST.GetCXAtomicOpFromExpressions($1,len($1) - 1)
                        if err != nil {
                                panic(err)
                        }

			lastOfThirdAtomicOp.Outputs.Fields = append(lastOfFirstAtomicOp.Outputs.Fields, lastOfThirdAtomicOp.Outputs.Fields...)
                        $$ = $3
                }
                ;

constant_expression:
                conditional_expression
                ;

declaration:
                VAR declarator declaration_specifiers SEMICOLON
                {
			$$ = actions.DeclareLocal(actions.AST,$2, $3, nil, false)
                }
        |       VAR declarator declaration_specifiers ASSIGN initializer SEMICOLON
                {
			$$ = actions.DeclareLocal(actions.AST,$2, $3, $5, true)
                }
                ;

initializer:    assignment_expression
                ;

// statements
statement:      labeled_statement
	|       compound_statement
	|       expression_statement
	|       selection_statement
	|       iteration_statement
        |       selector
        |       debugging
                { $$ = nil }
	|       jump_statement
                ;

labeled_statement:
                IDENTIFIER COLON block_item
                {
			// it has to be the first expression so all the nested expressions are executed
			// instead of only executing the last one
			// UPDATE: I need to label all expressions. `goto` will jump to first occurrance anyway, so no problem
			// I need this behavior for affordances
			for _, expr := range $3 {
                                if expr.Type==ast.CX_LINE{
                                        continue
                                }
                                expressionIdx :=expr.Index
				actions.AST.CXAtomicOps[expressionIdx].Label = $1
			}

			$$ = $3
                }
	|       CASE constant_expression COLON statement
                { $$ = nil }
	|       DEFAULT COLON statement
                { $$ = nil }
                ;

compound_statement:
                LBRACE RBRACE SEMICOLON
                { $$ = nil }
	|       LBRACE block_item_list RBRACE SEMICOLON
                {
                    $$ = $2
                }
                ;

block_item_list:
                block_item
	|       block_item_list block_item
                {
			$$ = append($1, $2...)
                }
                ;

block_item:     declaration
        |       statement
                ;

expression_statement:
                SEMICOLON
                { $$ = nil }
	|       expression SEMICOLON
                {          
                        var lastFirstAtomicOp *ast.CXAtomicOperator= &ast.CXAtomicOperator{Operator:-1}
                        var err error

                        if len($1) > 0 {
                                lastFirstAtomicOp, err = actions.AST.GetCXAtomicOpFromExpressions($1,len($1) - 1)
                                if err != nil {
                                        panic(err)
                                }
                        }
                       lastFirstAtomicOpOperator:=actions.AST.GetFunctionFromArray(lastFirstAtomicOp.Operator)

			if len($1) > 0 && lastFirstAtomicOpOperator == nil  && !$1[len($1) - 1].IsMethodCall() {
				outs := lastFirstAtomicOp.GetOutputs(actions.AST)
                               
				if len(outs) > 0 {
                                        outTypeSig:=actions.AST.GetCXTypeSignatureFromArray(outs[0])

                                        var expressionOutputArg *ast.CXArgument = &ast.CXArgument{}
			                if outTypeSig.Type == ast.TYPE_CXARGUMENT_DEPRECATE {
				                expressionOutputArg = actions.AST.GetCXArgFromArray(ast.CXArgumentIndex(outTypeSig.Meta))
			                } else {
				                panic("type is not cx argument deprecate\n\n")
			                }

					println(ast.CompilationError( expressionOutputArg.ArgDetails.FileName,  expressionOutputArg.ArgDetails.FileLine), "invalid expression")
				} else {
					println(ast.CompilationError(actions.CurrentFile, actions.LineNo), "invalid expression")
				}
				$$ = nil
			} else {
				$$ = $1
			}
			// $$ = $1
                }
                ;

selection_statement:
                IF conditional_expression LBRACE block_item_list RBRACE elseif_list else_statement SEMICOLON
                {
			$$ = actions.CreateSelectionStatement(actions.AST,$2, $4, $6, $7, actions.SEL_ELSEIFELSE)
                }
        |       IF conditional_expression LBRACE block_item_list RBRACE else_statement SEMICOLON
                {
			$$ = actions.SelectionExpressions(actions.AST,$2, $4, $6)
                }
        |       IF conditional_expression LBRACE RBRACE else_statement SEMICOLON
                {
			$$ = actions.SelectionExpressions(actions.AST,$2, nil, $5)
                }
        |       IF conditional_expression LBRACE block_item_list RBRACE elseif_list SEMICOLON
                {
			$$ = actions.CreateSelectionStatement(actions.AST,$2, $4, $6, nil, actions.SEL_ELSEIF)
                }
        |       IF conditional_expression LBRACE RBRACE elseif_list SEMICOLON
                {
			//
			$$ = actions.CreateSelectionStatement(actions.AST,$2, nil, $5, nil, actions.SEL_ELSEIF)
                }
        |       IF conditional_expression LBRACE RBRACE elseif_list else_statement SEMICOLON
                {
			//
			$$ = actions.CreateSelectionStatement(actions.AST,$2, nil, $5, $6, actions.SEL_ELSEIFELSE)
                }
        |       IF conditional_expression compound_statement
                {
			$$ = actions.SelectionExpressions(actions.AST,$2, $3, nil)
                }
	|       SWITCH LPAREN expression RPAREN statement
                { $$ = nil }
                ;

elseif:         ELSE IF conditional_expression LBRACE block_item_list RBRACE
                {
			$$ = actions.SelectStatement{
				Condition: $3,
				Then: $5,
			}
                }
	|       ELSE IF conditional_expression LBRACE RBRACE
		{
			$$ = actions.SelectStatement{
				Condition: $3,
				Then: nil,
			}
		}
                ;

elseif_list:    elseif
                {
			$$ = []actions.SelectStatement{$1}
                }
        |       elseif_list elseif
                {
			$$ = append($1, $2)
                }
        ;

else_statement:
                ELSE LBRACE block_item_list RBRACE
                {
			$$ = $3
                }
	|	ELSE LBRACE RBRACE
		{
			$$ = nil
		}
        ;

iteration_statement:
                FOR expression compound_statement
                {
			$$ = actions.IterationExpressions(actions.AST,nil, $2, nil, $3)
                }
        |       FOR expression_statement expression_statement compound_statement
                {			
			$$ = actions.IterationExpressions(actions.AST,$2, $3, nil, $4)
                }
        |       FOR expression_statement expression_statement expression compound_statement
                {
			$$ = actions.IterationExpressions(actions.AST,$2, $3, $4, $5)
                }
                ;

return_expression:
		struct_literal_expression
		{
			retExprs := actions.ReturnExpressions{Expressions: actions.AssociateReturnExpressions(actions.AST,0, $1)}
			retExprs.Size++
			$$ = retExprs
		}
	|	return_expression COMMA struct_literal_expression
		{
			$1.Expressions = append($1.Expressions, actions.AssociateReturnExpressions(actions.AST,$1.Size, $3)...)
			$1.Size++
			$$ = $1
		}
		;

jump_statement: GOTO IDENTIFIER SEMICOLON
                {
			pkg, err := actions.AST.GetCurrentPackage()
                        if err!=nil{
                                panic(err)
                        }
                        
                        exprCXLine := ast.MakeCXLineExpression(actions.AST, actions.CurrentFile, actions.LineNo, actions.LineStr)
                        expr := ast.MakeAtomicOperatorExpression(actions.AST,ast.Natives[constants.OP_GOTO])
                        expressionIdx :=expr.Index
                        actions.AST.CXAtomicOps[expressionIdx].Package = ast.CXPackageIndex(pkg.Index)
                        actions.AST.CXAtomicOps[expressionIdx].Label = $2
                        $$ = []ast.CXExpression{*exprCXLine,*expr}
			
                }
	|       CONTINUE SEMICOLON
		{
			$$ = actions.ContinueExpressions(actions.AST,)
		}
	|       BREAK SEMICOLON
		{
			$$ = actions.BreakExpressions(actions.AST,)
		}
	|       RETURN SEMICOLON
                {
			$$ = actions.AddJmpToReturnExpressions(actions.AST,actions.ReturnExpressions{})
                }
	|       RETURN return_expression SEMICOLON
                {
			$$ = actions.AddJmpToReturnExpressions(actions.AST,$2)
                }
                ;
%%
