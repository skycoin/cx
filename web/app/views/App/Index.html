{{set . "title" "CX Programming Language"}}
{{template "header.html" .}}

<div class ="container">
  <div class="page-header" id="banner">
    <div class="row">
      <div class="col-lg-6 col-md-6 col-sm-6">
        <h1>CX</h1>
        <p class="lead">A strongly typed programming language</p>

        <div class="row">
          <div class="col-lg-6 col-md-6 col-sm-6">
            <div class="list-group table-of-contents">
              <a class="list-group-item" href="#compiled-and-interpreted">Compiled and interpreted</a>
              <a class="list-group-item" href="#strict-typing-system">Strict typing system</a>
              <a class="list-group-item" href="#affordances">Affordances</a>
              <a class="list-group-item" href="#serialization">Serialization</a>
              <a class="list-group-item" href="#integrated-evolution-of-functions">Integrated evolution of functions</a>
              <a class="list-group-item" href="#interactive-debugging">Interactive debugging</a>
            </div>
          </div>
        </div>
      </div>
      
      <div class="col-lg-6 col-md-6 col-sm-6">
        <h1>CX Playground</h1>
        <p class="lead">Try CX online</p>
        <form action="/App/Index" method="post">
          <label for="example-select">Load example: </label>
          <select id="example-select" class="form-control" name="example-select" id="example-select">
            <option value="hello-world">Hello world</option>
            <option value="looping">Looping</option>
            <option value="factorial">Factorial</option>
            <option value="evolving-a-function">Evolving a function</option>
            <option value="more">More examples!</option>
          </select>
          <br />
          <textarea id="code-editor" class="form-control" name="code" rows="6">{{if .code}}{{raw .code}}{{else}}
package main

func main () (out str) {
	printStr("Hello World!")
}{{end}}</textarea>
          <br />
          <button type="submit" class="btn btn-primary">Run</button>
          <button id="clear-button" class="btn btn-warning">Clear</button>
          <br />
          <br />
          {{if .evalResult}}
          <div class="alert alert-success">{{raw .evalResult}}</div>
          {{end}}
        </form>
      </div>

      
      
    </div>    
  </div>

  <!-- Compiled and interpreted start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="compiled-and-interpreted">Compiled and interpreted</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>The CX specification enforces a CX dialect to provide the developer with both an interpreter and a compiler. An interpreted program is far slower than its compiled counterpart, as is expected, but will allow a more flexible program. This flexibility comes from meta-programming functions, and affordances, which can modify a program’s structure during runtime.</p>

        <p>A compiled program needs a more rigid structure than an interpreted program, as many of the optimizations leverage this rigidity. As a consequence, the affordance system and any function that operates over the program’s structure will be limited in functionality in a compiled program.</p>

        <p>The compiler should be used when performance is the biggest concern, while a program should remain being interpreted when the programmer requires all the flexibility provided by the CX features.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Compiled and interpreted end -->




  <!-- Strict typing system start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="strict-typing-system">Strict typing system</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>There is no implicit casting in CX. Because of this, multiple versions for each of the primitive types are defined in the core module. For example, four native functions for addition exist: addI32, addI64, addF32, and addF64.</p>
        
        <p>The parser attaches a default type to data it finds in the source code: if an integer is read, its default type is i32 or 32 bit integer; and if a float is read, its default type is f32 or 32 bit float. There is no ambiguity with other data read by the parser: true and false are always booleans; a series of characters enclosed between double quotes are always strings; and array needs to indicate its type before the list of its elements, e.g., []i64{1, 2, 3}.</p>

        <p>For the cases where the programmer needs to explicitly cast a value of one type to another, the core module provides a number of cast functions to work with primitive types. For example, byteAToStr casts a byte array to a string, and i32ToF32 casts a 32 bit integer to a 32 bit float.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Strict typing system end -->




  <!-- Affordances start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="affordances">Affordances</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>A programmer needs to make a plethora of decisions while constructing a program, e.g., how many parameters a function must receive, how many parameters it must return, what statements are needed to obtain the desired functionality, and what arguments need to be sent as parameters to the statement functions, among others. The affordance system in CX can be queried to obtain a list of the possible actions that can be applied to an element.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Affordances end -->


  <!-- Serialization start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="serialization">Serialization</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>A program in CX can be partially or fully serialized to a byte array. This serialization capability allows a program to create a program image (similar to system images), where the exact state at which the program was serialized is maintained. This means that a serialized program can be deserialized, and resume its execution later on. Serialiation can also be used to create backups.</p>

        <p>A CX program can leverage its integrated features to create some interesting scenarios. For example, a program can be serialized to create a backup of itself, and start an evolutionary algorithm on one of its functions. If the evolutionary algorithm finds a function that performs better than the previous definition, one can keep this new version of the program. However, if the evolutionary algorithm performed badly, the program can be restored to the saved backup. All of these tasks can be automated.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Serialization end -->




  <!-- Interactive evaluation start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="integrated-evolution-of-functions">Integrated evolution of function</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>The affordance system and meta-programming functions in CX allow the flexibility of changing the program’s structure in a supervised manner. However, affordances can still be automated by having a function that selects the index of the affordance to be applied.</p>

        <p><i>evolve</i> is a native function that constructs user-defined functions by using random affordances.</p>

        <p><i>evolve</i> follows the principles of evolutionary computation. In particular, evolve performs a technique called genetic programming. Genetic programming tries to find a combination of operators and arguments that will solve a problem. For example, you could instruct evolve to find a combination of operators that, when sent 10 as an argument, returns 20. This might sound trivial, but genetic programming and other evolutionary algorithms can solve very complicated problems.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Interactive evaluation end -->


  <!-- Interactive debugging start -->
  <div class="bs-docs-section">
    <div class="row">
      <div class="col-lg-12">
        <div class="page-header">
          <h1 id="interactive-debugging">Interactive debugging</h1>
        </div>
      </div>
    </div>

    <div class="row">
      <div class="col-lg-12">
        <!-- Content starts -->
        <p>A CX program will enter the REPL mode once an error has been found. This behaviour gives the programmer the opportunity to debug the program before attempting to resume its execution.</p>

        <!-- Content ends -->
      </div>
    </div>
    
  </div>
  <!-- Interactive debugging end -->
  
</div>

<script>
 $("#example-select").change(function () {
   if ($("#example-select").val() == "hello-world") {
     $("#code-editor").val("package main\n\
\n\
func main () (out str) {\n\
	printStr(\"Hello World!\")\n\
}")
   }

   if ($("#example-select").val() == "looping") {
     $("#code-editor").val("package main\n\
\n\
func main () (out i32) {\n\
	var out i32 = 0\n\
	for ltI32(out, 10) {\n\
		printI32(out)\n\
		out = addI32(out, 1)\n\
	}\n\
}")
   }

   if ($("#example-select").val() == "factorial") {
     $("#code-editor").val("package main\n\
\n\
func factorial (num i32) (fact i32) {\n\
	if eqI32(num, 1) {\n\
		fact := idI32(1)\n\
	} else {\n\
		fact := mulI32(num, factorial(subI32(num, 1)))\n\
	}\n\
}\n\
\n\
func main () (out i32) {\n\
	factorial(6)\n\
}")
   }


   if ($("#example-select").val() == "evolving-a-function") {
     $("#code-editor").val("package main\n\
\n\
var inps []f64 = []f64{\n\
	-10.0, -9.0, -8.0, -7.0, -6.0, -5.0, -4.0, -3.0, -2.0, -1.0,\n\
	0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0}\n\
\n\
var outs []f64 = []f64{\n\
	90.0, 72.0, 56.0, 42.0, 30.0, 20.0, 12.0, 6.0, 2.0, 0.0, 0.0,\n\
	2.0, 6.0, 12.0, 20.0, 30.0, 42.0, 56.0, 72.0, 90.0, 110.0}\n\
\n\
func solution (n f64) (out f64) {\n\
	square = mulF64(n, n)\n\
}\n\
\n\
func main () (out f64) {\n\
	:dStack false;\n\
	:dProgram true;\n\
	evolve(\"solution\", \"addF64|mulF64|subF64\", inps, outs, 5, 300, f32ToF64(0.1))\n\
\n\
	printStr(\"Extrapolating solution\")\n\
	printF64(solution(f32ToF64(30.0)))\n\
}")
   }

   if ($("#example-select").val() == "more") {
     window.location.replace("/App/Examples")
   }
     
 });
 
 $("#clear-button").click(function (event) {
   event.preventDefault();
   $("#code-editor").val("")
 });
 
</script>

{{template "footer.html" .}}
